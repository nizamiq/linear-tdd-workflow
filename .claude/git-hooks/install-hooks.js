#!/usr/bin/env node

/**
 * Git Hooks Installer for TDD Gate Enforcement
 *
 * Installs pre-commit and pre-push hooks that enforce TDD workflow
 * and quality gates for the Claude Agentic Workflow System.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class GitHooksInstaller {
  constructor() {
    this.projectRoot = process.cwd();
    this.gitHooksDir = path.join(this.projectRoot, '.git', 'hooks');
    this.claudeHooksDir = path.join(this.projectRoot, '.claude', 'git-hooks');

    // Ensure we're in a git repository
    if (!fs.existsSync(path.join(this.projectRoot, '.git'))) {
      throw new Error('Not a git repository. Please run "git init" first.');
    }
  }

  /**
   * Install all TDD enforcement hooks
   */
  async installHooks() {
    console.log('üîß Installing TDD enforcement git hooks...');

    try {
      // Create hooks directory if it doesn't exist
      if (!fs.existsSync(this.gitHooksDir)) {
        fs.mkdirSync(this.gitHooksDir, { recursive: true });
      }

      // Install individual hooks
      await this.installPreCommitHook();
      await this.installPrePushHook();
      await this.installCommitMsgHook();

      // Create TDD configuration file
      await this.createTDDConfig();

      console.log('‚úÖ TDD enforcement hooks installed successfully!');
      console.log('\nüìù Usage:');
      console.log(
        '   - Commit with [RED], [GREEN], or [REFACTOR] in message for TDD phase detection',
      );
      console.log('   - All commits are automatically validated for test coverage and quality');
      console.log('   - Use "git commit --no-verify" to bypass hooks (not recommended)');

      return true;
    } catch (error) {
      console.error('‚ùå Failed to install hooks:', error.message);
      return false;
    }
  }

  /**
   * Install pre-commit hook for TDD validation
   */
  async installPreCommitHook() {
    const hookPath = path.join(this.gitHooksDir, 'pre-commit');
    const hookContent = this.generatePreCommitHook();

    fs.writeFileSync(hookPath, hookContent, { mode: 0o755 });
    console.log('‚úÖ Pre-commit hook installed');
  }

  /**
   * Install pre-push hook for final validation
   */
  async installPrePushHook() {
    const hookPath = path.join(this.gitHooksDir, 'pre-push');
    const hookContent = this.generatePrePushHook();

    fs.writeFileSync(hookPath, hookContent, { mode: 0o755 });
    console.log('‚úÖ Pre-push hook installed');
  }

  /**
   * Install commit-msg hook for TDD message validation
   */
  async installCommitMsgHook() {
    const hookPath = path.join(this.gitHooksDir, 'commit-msg');
    const hookContent = this.generateCommitMsgHook();

    fs.writeFileSync(hookPath, hookContent, { mode: 0o755 });
    console.log('‚úÖ Commit-msg hook installed');
  }

  /**
   * Generate pre-commit hook script
   */
  generatePreCommitHook() {
    return `#!/bin/bash

# TDD Gate Enforcer - Pre-Commit Hook
# Generated by Claude Agentic Workflow System

set -e

echo "üîç TDD Gate Enforcer: Pre-commit validation..."

# Check if Node.js is available
if ! command -v node &> /dev/null; then
    echo "‚ùå Node.js is required for TDD enforcement"
    exit 1
fi

# Run TDD gate enforcer
if ! node .claude/git-hooks/tdd-gate-enforcer.js; then
    echo ""
    echo "‚ùå TDD Gate Enforcement failed!"
    echo "üí° Fix the violations above and try again"
    echo "üöÄ Or use 'git commit --no-verify' to bypass (not recommended)"
    exit 1
fi

echo "‚úÖ TDD Gate Enforcer: Pre-commit validation passed"
`;
  }

  /**
   * Generate pre-push hook script
   */
  generatePrePushHook() {
    return `#!/bin/bash

# TDD Gate Enforcer - Pre-Push Hook
# Generated by Claude Agentic Workflow System

set -e

echo "üöÄ TDD Gate Enforcer: Pre-push validation..."

# Run full test suite before push
echo "üß™ Running full test suite..."

if command -v npm &> /dev/null; then
    if ! npm test; then
        echo "‚ùå Tests failed! Fix tests before pushing."
        exit 1
    fi
elif command -v python &> /dev/null; then
    if ! python -m pytest; then
        echo "‚ùå Tests failed! Fix tests before pushing."
        exit 1
    fi
else
    echo "‚ö†Ô∏è No test runner found, skipping test validation"
fi

# Check coverage if available
if npm run coverage &> /dev/null; then
    echo "üìä Checking test coverage..."
    npm run coverage
fi

echo "‚úÖ TDD Gate Enforcer: Pre-push validation passed"
`;
  }

  /**
   * Generate commit-msg hook script
   */
  generateCommitMsgHook() {
    return `#!/bin/bash

# TDD Gate Enforcer - Commit Message Hook
# Generated by Claude Agentic Workflow System

commit_file="$1"
commit_msg=$(cat "$commit_file")

# Check for TDD phase indicators
if echo "$commit_msg" | grep -qE "\\[(RED|GREEN|REFACTOR)\\]"; then
    echo "üîç TDD phase detected in commit message"
fi

# Check for conventional commit format (optional)
if echo "$commit_msg" | grep -qE "^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\\(.+\\))?: .+"; then
    echo "‚úÖ Conventional commit format detected"
fi

# Prevent commits with TODO or FIXME in message (unless intentional)
if echo "$commit_msg" | grep -qE "\\b(TODO|FIXME)\\b"; then
    if ! echo "$commit_msg" | grep -qE "\\[allow-(todo|fixme)\\]"; then
        echo "‚ùå Commit message contains TODO or FIXME"
        echo "üí° Add [allow-todo] or [allow-fixme] if intentional"
        exit 1
    fi
fi

echo "‚úÖ Commit message validation passed"
`;
  }

  /**
   * Create TDD configuration file
   */
  async createTDDConfig() {
    const configDir = path.join(this.projectRoot, '.claude', 'config');
    const configPath = path.join(configDir, 'tdd-config.json');

    // Create config directory if it doesn't exist
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }

    // Don't overwrite existing config
    if (fs.existsSync(configPath)) {
      console.log('‚ÑπÔ∏è TDD config already exists, skipping creation');
      return;
    }

    const config = {
      minimumCoverage: 80,
      minimumDiffCoverage: 80,
      requireFailingTestFirst: true,
      allowSkippedTests: false,
      testTimeout: 30000,
      excludePatterns: [
        'node_modules/**',
        'coverage/**',
        '*.min.js',
        'dist/**',
        'build/**',
        '__pycache__/**',
        '*.pyc',
      ],
      testPatterns: [
        '**/*.test.js',
        '**/*.spec.js',
        '**/*.test.ts',
        '**/*.spec.ts',
        '**/test_*.py',
        'tests/**/*.py',
      ],
      hooks: {
        preCommit: {
          enabled: true,
          runTests: true,
          checkCoverage: true,
          enforcePhases: true,
        },
        prePush: {
          enabled: true,
          runFullTestSuite: true,
          checkOverallCoverage: true,
        },
        commitMsg: {
          enabled: true,
          enforceConventionalCommits: false,
          blockTodoFixme: true,
        },
      },
    };

    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    console.log('‚úÖ TDD configuration created at .claude/config/tdd-config.json');
  }

  /**
   * Uninstall hooks
   */
  async uninstallHooks() {
    console.log('üóëÔ∏è Removing TDD enforcement hooks...');

    const hooks = ['pre-commit', 'pre-push', 'commit-msg'];

    for (const hook of hooks) {
      const hookPath = path.join(this.gitHooksDir, hook);

      if (fs.existsSync(hookPath)) {
        // Check if it's our hook
        const content = fs.readFileSync(hookPath, 'utf8');
        if (content.includes('Claude Agentic Workflow System')) {
          fs.unlinkSync(hookPath);
          console.log(`‚úÖ Removed ${hook} hook`);
        } else {
          console.log(`‚ö†Ô∏è ${hook} hook exists but not created by us, skipping`);
        }
      }
    }

    console.log('‚úÖ TDD enforcement hooks removed');
  }

  /**
   * Check hook installation status
   */
  checkInstallation() {
    console.log('üîç Checking TDD hook installation status...');

    const hooks = ['pre-commit', 'pre-push', 'commit-msg'];
    const status = {};

    for (const hook of hooks) {
      const hookPath = path.join(this.gitHooksDir, hook);

      if (fs.existsSync(hookPath)) {
        const content = fs.readFileSync(hookPath, 'utf8');
        const isOurs = content.includes('Claude Agentic Workflow System');
        const isExecutable =
          (fs.statSync(hookPath).mode & parseInt('755', 8)) === parseInt('755', 8);

        status[hook] = {
          exists: true,
          isOurs,
          isExecutable,
          status: isOurs && isExecutable ? 'installed' : 'exists_but_not_ours',
        };
      } else {
        status[hook] = {
          exists: false,
          status: 'not_installed',
        };
      }
    }

    // Print status
    console.log('\nüìä Hook Installation Status:');
    for (const [hook, info] of Object.entries(status)) {
      const emoji =
        info.status === 'installed' ? '‚úÖ' : info.status === 'exists_but_not_ours' ? '‚ö†Ô∏è' : '‚ùå';
      console.log(`   ${emoji} ${hook}: ${info.status}`);
    }

    // Check TDD config
    const configPath = path.join(this.projectRoot, '.claude', 'config', 'tdd-config.json');
    const configExists = fs.existsSync(configPath);
    console.log(
      `   ${configExists ? '‚úÖ' : '‚ùå'} TDD config: ${configExists ? 'exists' : 'missing'}`,
    );

    return status;
  }

  /**
   * Test hooks without committing
   */
  async testHooks() {
    console.log('üß™ Testing TDD enforcement hooks...');

    try {
      // Test TDD gate enforcer directly
      const TDDGateEnforcer = require('./tdd-gate-enforcer.js');
      const enforcer = new TDDGateEnforcer();

      console.log('üîç Testing TDD gate enforcer...');
      const result = await enforcer.enforce();

      console.log('\nüìä Test Results:');
      console.log(`   Phase detected: ${enforcer.getResults().phase}`);
      console.log(`   Violations: ${enforcer.getResults().violations.length}`);
      console.log(`   Tests passed: ${result ? 'Yes' : 'No'}`);

      return result;
    } catch (error) {
      console.error('‚ùå Hook test failed:', error.message);
      return false;
    }
  }
}

// CLI interface
if (require.main === module) {
  const installer = new GitHooksInstaller();

  const command = process.argv[2] || 'install';

  switch (command) {
    case 'install':
      installer.installHooks();
      break;
    case 'uninstall':
      installer.uninstallHooks();
      break;
    case 'status':
      installer.checkInstallation();
      break;
    case 'test':
      installer.testHooks();
      break;
    default:
      console.log('Usage: node install-hooks.js [install|uninstall|status|test]');
      process.exit(1);
  }
}

module.exports = GitHooksInstaller;
