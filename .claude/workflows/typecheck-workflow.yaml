# Typecheck Workflow - Deterministic Type Safety Validation
# Replaces: TYPECHECKER agent (cost reduction: 95%)
#
# Use this workflow instead of invoking the TYPECHECKER agent for deterministic type checking.

name: typecheck-workflow
version: 1.0.0
description: Deterministic type safety validation across TypeScript and Python
type: workflow
cost_model: direct  # No LLM calls - deterministic tool execution only

# When to use this workflow
use_cases:
  - "Pre-commit type checking"
  - "CI/CD type safety enforcement"
  - "Incremental type checking on file changes"
  - "Full project type validation"

# When NOT to use (use agent instead)
avoid_for:
  - "Designing type system architecture"
  - "Complex generic type inference decisions"
  - "Type migration strategy planning"

# Execution modes
modes:
  check_only:
    description: "Check for type errors without fixing"
    dry_run: true

  strict:
    description: "Block on any type errors (CI mode)"
    on_failure: block

  incremental:
    description: "Check only changed files (fast feedback)"
    scope: changed_files

  full:
    description: "Check entire codebase (comprehensive)"
    scope: all_files

# Language-specific configurations
languages:
  typescript:
    tool: tsc
    config: tsconfig.json
    check_command: "npx tsc --noEmit"
    watch_command: "npx tsc --watch --noEmit"
    incremental_command: "npx tsc --noEmit --incremental"
    strict_flags: ["--strict", "--noImplicitAny", "--strictNullChecks"]

  python:
    tool: mypy
    config: pyproject.toml
    check_command: "mypy ."
    cache_dir: ".mypy_cache"
    strict_flags: ["--strict", "--warn-unreachable", "--warn-redundant-casts"]
    incremental: true

# Workflow steps
steps:
  - name: detect_language
    description: "Detect project language and type system"
    action: detect
    criteria:
      - if_exists: tsconfig.json
        then: typescript
      - if_exists: pyproject.toml AND has_mypy_config
        then: python

  - name: load_config
    description: "Load type checker configuration"
    action: read_config
    validate:
      - config_file_exists
      - config_is_valid_json_or_toml

  - name: determine_scope
    description: "Determine which files to check based on mode"
    action: scope_detection
    modes:
      incremental:
        command: "git diff --name-only HEAD"
        filter_pattern: ${language.file_extensions}

      full:
        command: "find . -type f"
        filter_pattern: ${language.file_extensions}

  - name: run_typecheck
    description: "Execute type checker"
    action: execute
    for_each: detected_languages
    command: ${language.check_command}
    timeout: 300  # 5 minutes max
    capture:
      - stdout
      - stderr
      - exit_code

  - name: parse_errors
    description: "Parse type errors into structured format"
    action: parse
    format: json
    schema:
      file: string
      line: number
      column: number
      error_code: string
      severity: enum[error, warning]
      message: string
      context: string  # Surrounding code

  - name: categorize_errors
    description: "Group errors by category for reporting"
    action: categorize
    categories:
      - name: strict_null_checks
        pattern: "Object is possibly 'null'|'undefined'"
      - name: implicit_any
        pattern: "implicitly has an 'any' type"
      - name: type_mismatch
        pattern: "Type .* is not assignable to type"
      - name: missing_properties
        pattern: "Property .* is missing"
      - name: unused_variables
        pattern: "declared but never used"

  - name: generate_report
    description: "Generate detailed type error report"
    action: report
    outputs:
      - total_errors: count
      - errors_by_category: map
      - files_with_errors: list
      - error_density: errors_per_1000_loc
      - new_errors: count_since_last_run
      - fixed_errors: count_since_last_run

# Success criteria
success_criteria:
  - name: no_type_errors
    check: total_errors == 0
    message: "Type checking passed - no errors found"

  - name: error_reduction
    check: new_errors == 0 OR fixed_errors > new_errors
    message: "Type safety improved since last run"

# Failure handling
on_failure:
  strict_mode:
    action: block
    message: "Type errors detected - commit/deploy blocked"
    exit_code: 1

  permissive_mode:
    action: warn
    message: "Type errors detected - review recommended"
    exit_code: 0

  gradual_mode:
    action: warn_on_new
    message: "New type errors introduced - fix before merging"
    check: new_errors > 0

# Performance optimization
performance:
  caching:
    enabled: true
    strategy: incremental
    cache_location:
      typescript: .tsbuildinfo
      python: .mypy_cache

  parallelization:
    enabled: true
    workers: 4  # Run type checking in parallel where possible

  incremental:
    enabled: true
    baseline: "main"  # Compare against main branch

# Integration points
hooks:
  pre_commit:
    enabled: true
    mode: incremental
    command: "workflow run typecheck-workflow --mode=incremental --on-failure=block"

  post_merge:
    enabled: true
    mode: full
    command: "workflow run typecheck-workflow --mode=full"
    async: false

  ci_pipeline:
    enabled: true
    mode: strict
    command: "workflow run typecheck-workflow --mode=full --on-failure=block"

# Metrics
metrics:
  typical_duration:
    incremental: "2-10 seconds"
    full: "15-90 seconds"

  cost_vs_agent: "95% reduction"
  reliability: "100% deterministic"

# Migration guide
migration:
  from: "TYPECHECKER agent"
  steps:
    - "Remove agent invocations: /invoke TYPECHECKER:*"
    - "Add to hooks.json: pre-commit typecheck workflow"
    - "Update CI to use workflow"
    - "Enable incremental mode for faster feedback"

  benefits:
    - "95% cost reduction (no LLM calls)"
    - "100% deterministic results"
    - "Faster feedback (incremental mode)"
    - "Better IDE integration"

# Usage examples
examples:
  quick_check:
    command: "workflow run typecheck-workflow --mode=incremental"
    description: "Fast check of changed files only"

  full_validation:
    command: "workflow run typecheck-workflow --mode=full --on-failure=strict"
    description: "Comprehensive type check with blocking"

  watch_mode:
    command: "workflow run typecheck-workflow --mode=watch"
    description: "Continuous type checking during development"

  specific_files:
    command: "workflow run typecheck-workflow --files='src/components/**/*.ts'"
    description: "Type check specific file patterns"

# TypeScript-specific optimizations
typescript:
  project_references:
    enabled: false  # Enable for monorepos
    description: "Use TypeScript project references for faster builds"

  skipLibCheck:
    enabled: true
    description: "Skip type checking of .d.ts files for speed"

  incremental:
    enabled: true
    description: "Use incremental compilation for faster re-checks"

# Python-specific optimizations
python:
  strict_optional:
    enabled: true
    description: "Enforce strict None checking"

  follow_imports:
    strategy: "normal"  # normal | silent | skip | error
    description: "How to handle imported modules"

  ignore_missing_imports:
    enabled: false
    description: "Whether to ignore missing stub files"

# Error fixing guidance
error_patterns:
  implicit_any:
    detection: "Parameter .* implicitly has an 'any' type"
    fix_hint: "Add explicit type annotation: name: string"
    severity: error

  null_checks:
    detection: "Object is possibly 'null'"
    fix_hint: "Use optional chaining (?.) or null check"
    severity: error

  type_mismatch:
    detection: "Type .* is not assignable to type"
    fix_hint: "Ensure types match or use type assertion"
    severity: error

  unused_variable:
    detection: ".* is declared but never used"
    fix_hint: "Remove unused variable or prefix with underscore"
    severity: warning

# Related workflows
related:
  - lint-workflow.yaml  # Run linting alongside type checking
  - validation-workflow.yaml  # Comprehensive validation including types
  - tdd-cycle-workflow.yaml  # TDD with type safety enforcement

---

# Implementation Notes

## Why This Replaces TYPECHECKER Agent

The TYPECHECKER agent was autonomous logic for a deterministic task. This workflow:
- Eliminates all LLM calls (95% cost reduction)
- Provides 100% deterministic, repeatable results
- Runs significantly faster (no model latency)
- Integrates with IDE tooling
- Supports incremental checking for instant feedback

## When You Still Need an Agent

Use TYPESCRIPT-PRO or PYTHON-PRO agents (not TYPECHECKER) for:
- Designing complex generic type systems
- Type architecture decisions
- Migration strategies (any → strict)
- Advanced type inference patterns
- Type system performance tuning

Use TYPECHECKER workflow for:
- ✅ Automated type checking (pre-commit, CI/CD)
- ✅ Incremental validation during development
- ✅ Type error detection and reporting
- ✅ Blocking deployments on type errors

## Hook Integration Example

Add to `.claude/hooks.json`:
```json
{
  "pre-tool-use": {
    "git-commit": {
      "command": "workflow run typecheck-workflow --mode=incremental --on-failure=block",
      "description": "Type check before commits",
      "required": true,
      "timeout": 60
    }
  },
  "post-merge": {
    "full_typecheck": {
      "command": "workflow run typecheck-workflow --mode=full",
      "description": "Full type check after merge",
      "async": true
    }
  }
}
```

## CI/CD Integration

### GitHub Actions
```yaml
- name: Type Check
  run: workflow run typecheck-workflow --mode=full --on-failure=block
```

### Pre-commit Hook
```bash
#!/bin/bash
workflow run typecheck-workflow --mode=incremental --on-failure=block
```

## Incremental Mode Benefits

For TDD workflow, incremental mode provides:
- **2-5 second feedback** (vs 30-60s full check)
- **Immediate type error detection** during RED phase
- **No interruption to flow** - runs in background
- **Lower cognitive load** - focused errors only

---

**Status**: Active - use instead of TYPECHECKER agent
**Cost Impact**: 95% reduction vs agent approach
**Reliability**: 100% deterministic
**Speed**: 5-10x faster than agent invocation
