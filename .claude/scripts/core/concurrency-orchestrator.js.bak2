#!/usr/bin/env node

/**
 * Concurrency Orchestrator - Simple coordination system for Phase B.1
 *
 * Evidence-based design:
 * - Max 3 concurrent agents (conservative start)
 * - MCP queue management with 2-operation limits
 * - Simple coordination and monitoring
 * - Graceful error handling and recovery
 */

const EventEmitter = require('events');
// Native ANSI colors to replace chalk
const colors = {
  red: (text) => `[31m${text}[0m`,
  green: (text) => `[32m${text}[0m`,
  yellow: (text) => `[33m${text}[0m`,
  blue: (text) => `[34m${text}[0m`,
  magenta: (text) => `[35m${text}[0m`,
  cyan: (text) => `[36m${text}[0m`,
  white: (text) => `[37m${text}[0m`,
  gray: (text) => `[90m${text}[0m`,
  bold: (text) => `[1m${text}[0m`
};
const McpQueueManager = require('./mcp-queue-manager');
const AgentPool = require('./agent-pool');
const PerformanceMonitor = require('./performance-monitor');
const ErrorRecoveryManager = require('./error-recovery-manager');

class ConcurrencyOrchestrator extends EventEmitter {
  constructor(options = {}) {
    super();

    this.config = {
      monitoringInterval: 10000, // 10 seconds
      statusDisplayInterval: 30000, // 30 seconds
      healthCheckInterval: 60000, // 1 minute
      ...options
    };

    // Initialize components
    this.errorRecoveryManager = new ErrorRecoveryManager(options.errorRecoveryConfig);
    this.mcpQueueManager = new McpQueueManager(options.mcpConfig);
    this.agentPool = new AgentPool(this.mcpQueueManager, options.agentConfig);
    this.performanceMonitor = new PerformanceMonitor(options.monitoringConfig);

    // Wire up error handling
    this.setupErrorHandling();

    // Connect error recovery to MCP queue manager
    this.mcpQueueManager.setErrorRecoveryManager(this.errorRecoveryManager);

    // System state
    this.isRunning = false;
    this.startTime = null;
    this.monitoringTimers = [];

    // Metrics aggregation
    this.systemMetrics = {
      totalTasks: 0,
      completedTasks: 0,
      failedTasks: 0,
      uptime: 0,
      throughput: 0, // tasks per minute
      systemLoad: 0 // 0-1 scale
    };

    console.log(chalk.bold.green('🎭 Concurrency Orchestrator initialized'));
  }

  /**
   * Setup error handling integration
   */
  setupErrorHandling() {
    // Listen for performance alerts that might require error handling
    this.performanceMonitor.on('alert', (alert) => {
      if (alert.severity === 'critical') {
        this.errorRecoveryManager.handleError('system_overload', {
          alertType: alert.type,
          value: alert.value,
          threshold: alert.threshold
        });
      }
    });

    // Listen for circuit breaker events
    this.errorRecoveryManager.on('circuit-breaker-opened', (event) => {
      console.log(chalk.yellow(`🔌 Circuit breaker opened for ${event.serverName} - operations will be blocked`));
    });

    this.errorRecoveryManager.on('circuit-breaker-closed', (event) => {
      console.log(chalk.green(`🔌 Circuit breaker closed for ${event.serverName} - operations resumed`));
    });

    // Listen for health degradation
    this.errorRecoveryManager.on('health-critical', (health) => {
      console.log(chalk.red(`🚨 CRITICAL: System health compromised - ${health.reason}`));
    });
  }

  /**
   * Start the orchestration system
   */
  async start() {
    if (this.isRunning) {
      console.log(chalk.yellow('⚠️  Orchestrator already running'));
      return;
    }

    console.log(chalk.bold.cyan('\n🚀 Starting Concurrency Orchestrator\n'));

    this.startTime = Date.now();
    this.isRunning = true;

    // Start error recovery monitoring
    this.errorRecoveryManager.start();

    // Start performance monitoring
    this.performanceMonitor.start(this, this.mcpQueueManager, this.agentPool);

    // Start monitoring
    this.startMonitoring();

    // Setup graceful shutdown
    this.setupGracefulShutdown();

    console.log(chalk.green('✅ Concurrency Orchestrator started successfully\n'));

    // Emit start event
    this.emit('started');
  }

  /**
   * Execute a workflow with multiple tasks
   */
  async executeWorkflow(workflowSpec) {
    if (!this.isRunning) {
      throw new Error('Orchestrator not running');
    }

    const workflowId = this.generateWorkflowId();
    const startTime = Date.now();

    console.log(chalk.bold.blue(`🎯 Starting workflow ${workflowId}: ${workflowSpec.name}`));

    try {
      // Parse workflow tasks
      const tasks = this.parseWorkflowTasks(workflowSpec);

      // Execute tasks based on strategy
      const results = await this.executeTaskStrategy(tasks, workflowSpec.strategy || 'parallel');

      const duration = Date.now() - startTime;

      console.log(chalk.green(`✅ Workflow ${workflowId} completed in ${duration}ms`));

      // Update system metrics
      this.updateSystemMetrics(tasks.length, results);

      return {
        workflowId,
        duration,
        results,
        totalTasks: tasks.length,
        successfulTasks: results.filter(r => !r.error).length
      };

    } catch (error) {
      const duration = Date.now() - startTime;
      console.log(chalk.red(`❌ Workflow ${workflowId} failed after ${duration}ms: ${error.message}`));

      throw error;
    }
  }

  /**
   * Parse workflow specification into executable tasks
   */
  parseWorkflowTasks(workflowSpec) {
    const tasks = [];

    if (workflowSpec.tasks) {
      // Direct task list
      for (const taskSpec of workflowSpec.tasks) {
        tasks.push({
          agentType: taskSpec.agent,
          command: taskSpec.command,
          params: taskSpec.params,
          priority: taskSpec.priority || 'normal',
          dependencies: taskSpec.dependencies || []
        });
      }
    } else if (workflowSpec.type) {
      // Predefined workflow types
      tasks.push(...this.getWorkflowTasks(workflowSpec.type, workflowSpec.params));
    }

    return tasks;
  }

  /**
   * Get predefined workflow tasks
   */
  getWorkflowTasks(workflowType, params = {}) {
    const workflows = {
      // Code assessment workflow
      assess: [
        {
          agentType: 'auditor',
          command: 'assess-code',
          params: { scope: params.scope || 'changed' },
          priority: 'high'
        }
      ],

      // Fix implementation workflow
      fix: [
        {
          agentType: 'executor',
          command: 'implement-fix',
          params: { taskId: params.taskId, testFirst: true },
          priority: 'high'
        },
        {
          agentType: 'tester',
          command: 'run-tests',
          params: { coverage: true },
          priority: 'normal',
          dependencies: ['executor']
        },
        {
          agentType: 'reviewer',
          command: 'review-changes',
          params: { thorough: true },
          priority: 'normal',
          dependencies: ['executor']
        }
      ],

      // Comprehensive analysis workflow
      analyze: [
        {
          agentType: 'auditor',
          command: 'assess-code',
          params: { scope: 'full' },
          priority: 'high'
        },
        {
          agentType: 'securityguard',
          command: 'security-scan',
          params: { deep: true },
          priority: 'normal'
        },
        {
          agentType: 'analyzer',
          command: 'complexity-analysis',
          params: { detailed: true },
          priority: 'normal'
        }
      ],

      // Testing workflow
      test: [
        {
          agentType: 'tester',
          command: 'run-unit-tests',
          params: { coverage: true },
          priority: 'high'
        },
        {
          agentType: 'tester',
          command: 'run-integration-tests',
          params: {},
          priority: 'normal'
        },
        {
          agentType: 'validator',
          command: 'validate-coverage',
          params: { threshold: 80 },
          priority: 'normal',
          dependencies: ['tester']
        }
      ]
    };

    return workflows[workflowType] || [];
  }

  /**
   * Execute tasks based on strategy (parallel, sequential, dependency-aware)
   */
  async executeTaskStrategy(tasks, strategy) {
    switch (strategy) {
      case 'sequential':
        return this.executeSequential(tasks);
      case 'dependency-aware':
        return this.executeDependencyAware(tasks);
      case 'parallel':
      default:
        return this.executeParallel(tasks);
    }
  }

  /**
   * Execute tasks in parallel (respecting agent pool limits)
   */
  async executeParallel(tasks) {
    console.log(chalk.blue(`🔀 Executing ${tasks.length} tasks in parallel`));

    const taskPromises = tasks.map(task =>
      this.agentPool.executeTask(task).catch(error => ({
        error: error.message,
        task: task
      }))
    );

    return Promise.all(taskPromises);
  }

  /**
   * Execute tasks sequentially
   */
  async executeSequential(tasks) {
    console.log(chalk.blue(`➡️  Executing ${tasks.length} tasks sequentially`));

    const results = [];

    for (const task of tasks) {
      try {
        const result = await this.agentPool.executeTask(task);
        results.push(result);
      } catch (error) {
        results.push({
          error: error.message,
          task: task
        });
      }
    }

    return results;
  }

  /**
   * Execute tasks with dependency awareness
   */
  async executeDependencyAware(tasks) {
    console.log(chalk.blue(`🕸️  Executing ${tasks.length} tasks with dependency awareness`));

    // Simple dependency resolution for Phase B.1
    // More sophisticated topological sorting could be added later

    const completed = new Set();
    const results = [];
    const taskMap = new Map(tasks.map((task, index) => [index, task]));

    // Execute tasks in waves based on dependencies
    while (completed.size < tasks.length) {
      const readyTasks = [];

      for (const [index, task] of taskMap.entries()) {
        if (completed.has(index)) continue;

        // Check if dependencies are satisfied
        const dependenciesMet = (task.dependencies || []).every(dep =>
          completed.has(tasks.findIndex(t => t.agentType === dep))
        );

        if (dependenciesMet) {
          readyTasks.push({ index, task });
        }
      }

      if (readyTasks.length === 0) {
        throw new Error('Circular dependency detected in workflow');
      }

      // Execute ready tasks in parallel
      const wavePromises = readyTasks.map(async ({ index, task }) => {
        try {
          const result = await this.agentPool.executeTask(task);
          completed.add(index);
          return { index, result };
        } catch (error) {
          completed.add(index);
          return {
            index,
            result: {
              error: error.message,
              task: task
            }
          };
        }
      });

      const waveResults = await Promise.all(wavePromises);
      results.push(...waveResults);
    }

    // Sort results by original task order
    return results
      .sort((a, b) => a.index - b.index)
      .map(item => item.result);
  }

  /**
   * Start monitoring and status display
   */
  startMonitoring() {
    // Performance monitoring
    const monitoringTimer = setInterval(() => {
      this.collectMetrics();
    }, this.config.monitoringInterval);

    // Status display
    const statusTimer = setInterval(() => {
      this.displaySystemStatus();
    }, this.config.statusDisplayInterval);

    // Health checks
    const healthTimer = setInterval(() => {
      this.performHealthCheck();
    }, this.config.healthCheckInterval);

    this.monitoringTimers.push(monitoringTimer, statusTimer, healthTimer);
  }

  /**
   * Collect system metrics
   */
  collectMetrics() {
    const agentStatus = this.agentPool.getStatus();
    const mcpStatus = this.mcpQueueManager.getStatus();

    // Calculate system load (0-1 scale)
    const agentUtilization = agentStatus.currentState.activeAgents / agentStatus.configuration.maxConcurrentAgents;
    const mcpUtilization = Object.values(mcpStatus.activeCounts).reduce((sum, count, index) => {
      const limit = Object.values(mcpStatus.serverLimits)[index];
      return sum + (count / limit);
    }, 0) / Object.keys(mcpStatus.serverLimits).length;

    this.systemMetrics.systemLoad = Math.max(agentUtilization, mcpUtilization);

    // Calculate uptime
    this.systemMetrics.uptime = Date.now() - this.startTime;

    // Calculate throughput (tasks per minute)
    const totalCompleted = agentStatus.metrics.completedTasks;
    const uptimeMinutes = this.systemMetrics.uptime / 60000;
    this.systemMetrics.throughput = uptimeMinutes > 0 ? totalCompleted / uptimeMinutes : 0;

    // Emit metrics event
    this.emit('metrics', this.systemMetrics);
  }

  /**
   * Update system metrics after workflow completion
   */
  updateSystemMetrics(taskCount, results) {
    this.systemMetrics.totalTasks += taskCount;
    this.systemMetrics.completedTasks += results.filter(r => !r.error).length;
    this.systemMetrics.failedTasks += results.filter(r => r.error).length;
  }

  /**
   * Perform system health check
   */
  performHealthCheck() {
    const agentStatus = this.agentPool.getStatus();
    const mcpStatus = this.mcpQueueManager.getStatus();

    // Check for concerning metrics
    const warnings = [];

    // High failure rate
    const successRate = parseFloat(mcpStatus.metrics.successRate);
    if (successRate < 90) {
      warnings.push(`Low MCP success rate: ${successRate}%`);
    }

    // High response times
    if (mcpStatus.metrics.averageResponseTime > 1000) {
      warnings.push(`High MCP response time: ${mcpStatus.metrics.averageResponseTime.toFixed(0)}ms`);
    }

    // Queue buildup
    const totalQueued = Object.values(mcpStatus.queueSizes).reduce((sum, size) => sum + size, 0);
    if (totalQueued > 10) {
      warnings.push(`High queue buildup: ${totalQueued} operations`);
    }

    if (warnings.length > 0) {
      console.log(chalk.yellow('\n⚠️  Health Check Warnings:'));
      warnings.forEach(warning => console.log(chalk.yellow(`   - ${warning}`)));
      console.log();
    }

    // Emit health event
    this.emit('health', {
      healthy: warnings.length === 0,
      warnings,
      timestamp: Date.now()
    });
  }

  /**
   * Display comprehensive system status
   */
  displaySystemStatus() {
    console.log(chalk.bold.cyan('\n🎭 Concurrency Orchestrator Status'));
    console.log(chalk.blue('═'.repeat(60)));

    // System overview
    const uptimeMinutes = (this.systemMetrics.uptime / 60000).toFixed(1);
    const loadPercentage = (this.systemMetrics.systemLoad * 100).toFixed(1);

    console.log(chalk.white(`Uptime:             ${uptimeMinutes} minutes`));
    console.log(chalk.white(`System Load:        ${loadPercentage}%`));
    console.log(chalk.white(`Throughput:         ${this.systemMetrics.throughput.toFixed(1)} tasks/min`));
    console.log(chalk.white(`Total Tasks:        ${this.systemMetrics.totalTasks}`));

    // Component status
    this.agentPool.displayStatus();
    this.mcpQueueManager.displayStatus();

    console.log(chalk.blue('═'.repeat(60)));
  }

  /**
   * Setup graceful shutdown handlers
   */
  setupGracefulShutdown() {
    const gracefulShutdown = async (signal) => {
      console.log(chalk.yellow(`\n🛑 Received ${signal}, initiating graceful shutdown...`));
      await this.shutdown();
      process.exit(0);
    };

    process.on('SIGINT', gracefulShutdown);
    process.on('SIGTERM', gracefulShutdown);
  }

  /**
   * Gracefully shutdown the orchestrator
   */
  async shutdown(timeout = 60000) {
    if (!this.isRunning) {
      return;
    }

    console.log(chalk.yellow('🛑 Shutting down Concurrency Orchestrator...'));

    this.isRunning = false;

    // Stop error recovery monitoring
    this.errorRecoveryManager.stop();

    // Stop performance monitoring
    this.performanceMonitor.stop();

    // Clear monitoring timers
    this.monitoringTimers.forEach(timer => clearInterval(timer));
    this.monitoringTimers = [];

    // Shutdown components
    await Promise.all([
      this.agentPool.shutdown(timeout),
      this.mcpQueueManager.shutdown(timeout)
    ]);

    console.log(chalk.green('✅ Concurrency Orchestrator shutdown complete'));

    // Emit shutdown event
    this.emit('shutdown');
  }

  /**
   * Generate unique workflow ID
   */
  generateWorkflowId() {
    return `workflow-${Date.now()}-${Math.random().toString(36).substring(2, 6)}`;
  }

  /**
   * Get comprehensive system status
   */
  getSystemStatus() {
    return {
      orchestrator: {
        isRunning: this.isRunning,
        uptime: this.systemMetrics.uptime,
        systemLoad: this.systemMetrics.systemLoad,
        throughput: this.systemMetrics.throughput
      },
      agentPool: this.agentPool.getStatus(),
      mcpQueueManager: this.mcpQueueManager.getStatus(),
      systemMetrics: this.systemMetrics,
      performanceMetrics: this.performanceMonitor.getMetricsSummary(),
      errorRecovery: this.errorRecoveryManager.getErrorStats()
    };
  }

  /**
   * Export performance metrics to file
   */
  async exportPerformanceMetrics(filePath) {
    return this.performanceMonitor.exportMetrics(filePath);
  }
}

module.exports = ConcurrencyOrchestrator;