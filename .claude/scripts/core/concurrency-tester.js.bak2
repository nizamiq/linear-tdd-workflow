#!/usr/bin/env node

/**
 * Concurrency Tester - Empirical analysis of current system limits
 *
 * Tests the actual constraints and bottlenecks in our multi-agent system
 * to inform evidence-based concurrency design decisions.
 */

const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
// Native ANSI colors to replace chalk
const colors = {
  red: (text) => `[31m${text}[0m`,
  green: (text) => `[32m${text}[0m`,
  yellow: (text) => `[33m${text}[0m`,
  blue: (text) => `[34m${text}[0m`,
  magenta: (text) => `[35m${text}[0m`,
  cyan: (text) => `[36m${text}[0m`,
  white: (text) => `[37m${text}[0m`,
  gray: (text) => `[90m${text}[0m`,
  bold: (text) => `[1m${text}[0m`
};
const os = require('os');

class ConcurrencyTester {
  constructor() {
    this.results = {
      taskToolLimits: {},
      resourceUsage: {},
      mcpServerLimits: {},
      fileConflicts: {},
      timestamp: new Date().toISOString()
    };
    this.testId = `concurrency-test-${Date.now()}`;
  }

  /**
   * Run comprehensive concurrency analysis
   */
  async runAnalysis() {
    console.log(chalk.bold.cyan('\nüî¨ Phase B.0: Concurrency Analysis\n'));
    console.log(chalk.yellow(`Test ID: ${this.testId}\n`));

    try {
      // Task 1: Test concurrent Task tool invocations
      await this.testTaskToolConcurrency();

      // Task 2: Measure resource usage patterns
      await this.measureResourceUsage();

      // Task 3: Test MCP server constraints
      await this.testMcpServerLimits();

      // Task 4: Analyze file system conflicts
      await this.analyzeFileConflicts();

      // Generate comprehensive report
      await this.generateReport();

      console.log(chalk.bold.green('\n‚úÖ Concurrency analysis complete!\n'));
      console.log(chalk.blue(`Report saved to: .claude/analysis/${this.testId}.json\n`));

    } catch (error) {
      console.error(chalk.red(`Analysis failed: ${error.message}`));
      throw error;
    }
  }

  /**
   * Test Task tool concurrent invocation capabilities
   */
  async testTaskToolConcurrency() {
    console.log(chalk.yellow('üìã Testing Task tool concurrency limits...\n'));

    const tests = [
      { agents: 1, description: 'Baseline single agent' },
      { agents: 2, description: 'Dual agent execution' },
      { agents: 3, description: 'Triple agent execution' },
      { agents: 5, description: 'Stress test (5 agents)' }
    ];

    for (const test of tests) {
      console.log(chalk.blue(`  Testing ${test.agents} concurrent agents...`));

      const startTime = Date.now();
      const startMemory = process.memoryUsage();

      try {
        const results = await this.runConcurrentTasks(test.agents);
        const duration = Date.now() - startTime;
        const endMemory = process.memoryUsage();

        this.results.taskToolLimits[test.agents] = {
          success: true,
          duration,
          memoryDelta: endMemory.heapUsed - startMemory.heapUsed,
          results,
          description: test.description
        };

        console.log(chalk.green(`    ‚úÖ Success - ${duration}ms, ${results.length} completions`));

      } catch (error) {
        this.results.taskToolLimits[test.agents] = {
          success: false,
          error: error.message,
          description: test.description
        };

        console.log(chalk.red(`    ‚ùå Failed - ${error.message}`));
        break; // Stop testing higher concurrency if this level fails
      }

      // Cool down between tests
      await this.sleep(2000);
    }
  }

  /**
   * Run multiple Task tool invocations concurrently
   */
  async runConcurrentTasks(agentCount) {
    const tasks = [];

    for (let i = 0; i < agentCount; i++) {
      // Use simple read-only tasks to test concurrency without side effects
      const task = this.invokeMockAgent(`test-agent-${i}`, {
        task: 'analyze',
        scope: 'minimal',
        readonly: true
      });
      tasks.push(task);
    }

    return Promise.all(tasks);
  }

  /**
   * Mock agent invocation for testing (simulates Task tool usage)
   */
  async invokeMockAgent(agentName, config) {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();

      // Simulate agent work with filesystem operations (using project root, not .claude dir)
      const projectRoot = path.join(__dirname, '..', '..', '..');
      const testOperations = [
        () => fs.readFile(path.join(projectRoot, 'package.json'), 'utf8').catch(() => 'mock package.json'),
        () => fs.readdir(projectRoot).catch(() => ['mock', 'files']),
        () => this.sleep(Math.random() * 1000 + 500) // Variable processing time
      ];

      Promise.all(testOperations.map(op => op()))
        .then(results => {
          resolve({
            agent: agentName,
            duration: Date.now() - startTime,
            operations: results.length,
            memoryUsage: process.memoryUsage(),
            pid: process.pid
          });
        })
        .catch(reject);
    });
  }

  /**
   * Measure system resource usage patterns
   */
  async measureResourceUsage() {
    console.log(chalk.yellow('\nüìä Measuring resource usage patterns...\n'));

    const baseline = await this.getSystemResources();
    console.log(chalk.blue('  Baseline system resources captured'));

    // Test resource usage under different loads
    const loadTests = [1, 2, 3, 5];

    for (const load of loadTests) {
      console.log(chalk.blue(`  Testing resource usage with ${load} concurrent operations...`));

      const beforeResources = await this.getSystemResources();

      // Simulate concurrent work
      const workPromises = Array(load).fill().map((_, i) =>
        this.simulateAgentWork(`resource-test-${i}`)
      );

      const workResults = await Promise.all(workPromises);
      const afterResources = await this.getSystemResources();

      this.results.resourceUsage[load] = {
        beforeResources,
        afterResources,
        workResults,
        cpuDelta: afterResources.cpu - beforeResources.cpu,
        memoryDelta: afterResources.memory - beforeResources.memory
      };

      console.log(chalk.green(`    ‚úÖ Load test ${load} complete`));
      await this.sleep(1000);
    }

    this.results.resourceUsage.baseline = baseline;
  }

  /**
   * Test MCP server concurrency limits
   */
  async testMcpServerLimits() {
    console.log(chalk.yellow('\nüîå Testing MCP server concurrency limits...\n'));

    // Test different MCP operations
    const mcpTests = [
      {
        name: 'linear-server',
        operation: 'list_issues',
        concurrent: [1, 2, 3]
      },
      {
        name: 'sequential-thinking',
        operation: 'sequential_thinking',
        concurrent: [1, 2]
      }
    ];

    for (const mcpTest of mcpTests) {
      console.log(chalk.blue(`  Testing ${mcpTest.name} server...`));

      for (const concurrency of mcpTest.concurrent) {
        try {
          const startTime = Date.now();

          // Simulate concurrent MCP calls
          const operations = Array(concurrency).fill().map((_, i) =>
            this.simulateMcpOperation(mcpTest.name, mcpTest.operation, i)
          );

          const results = await Promise.all(operations);
          const duration = Date.now() - startTime;

          if (!this.results.mcpServerLimits[mcpTest.name]) {
            this.results.mcpServerLimits[mcpTest.name] = {};
          }

          this.results.mcpServerLimits[mcpTest.name][concurrency] = {
            success: true,
            duration,
            results: results.length,
            avgResponseTime: duration / results.length
          };

          console.log(chalk.green(`    ‚úÖ ${concurrency} concurrent ops - ${duration}ms`));

        } catch (error) {
          if (!this.results.mcpServerLimits[mcpTest.name]) {
            this.results.mcpServerLimits[mcpTest.name] = {};
          }

          this.results.mcpServerLimits[mcpTest.name][concurrency] = {
            success: false,
            error: error.message
          };

          console.log(chalk.red(`    ‚ùå ${concurrency} concurrent ops failed`));
          break;
        }

        await this.sleep(1000);
      }
    }
  }

  /**
   * Analyze file system conflict patterns
   */
  async analyzeFileConflicts() {
    console.log(chalk.yellow('\nüìÅ Analyzing file system conflict patterns...\n'));

    // Test different conflict scenarios
    const conflictTests = [
      {
        name: 'same-file-read',
        description: 'Multiple agents reading same file',
        operations: (count) => Array(count).fill().map((_, i) =>
          this.simulateFileRead('package.json', `reader-${i}`)
        )
      },
      {
        name: 'different-files-read',
        description: 'Multiple agents reading different files',
        operations: (count) => Array(count).fill().map((_, i) =>
          this.simulateFileRead(['.gitignore', 'package.json', 'README.md'][i % 3], `reader-${i}`)
        )
      },
      {
        name: 'temp-file-writes',
        description: 'Multiple agents writing to temp files',
        operations: (count) => Array(count).fill().map((_, i) =>
          this.simulateFileWrite(`/tmp/test-${this.testId}-${i}.json`, `writer-${i}`)
        )
      }
    ];

    for (const test of conflictTests) {
      console.log(chalk.blue(`  Testing ${test.name}...`));

      for (const concurrency of [1, 2, 3, 5]) {
        try {
          const startTime = Date.now();
          const operations = test.operations(concurrency);

          const results = await Promise.all(operations);
          const duration = Date.now() - startTime;

          if (!this.results.fileConflicts[test.name]) {
            this.results.fileConflicts[test.name] = {};
          }

          this.results.fileConflicts[test.name][concurrency] = {
            success: true,
            duration,
            results: results.length,
            description: test.description
          };

          console.log(chalk.green(`    ‚úÖ ${concurrency} concurrent ${test.name} - ${duration}ms`));

        } catch (error) {
          if (!this.results.fileConflicts[test.name]) {
            this.results.fileConflicts[test.name] = {};
          }

          this.results.fileConflicts[test.name][concurrency] = {
            success: false,
            error: error.message,
            description: test.description
          };

          console.log(chalk.red(`    ‚ùå ${concurrency} concurrent ${test.name} failed`));
          break;
        }

        await this.sleep(500);
      }
    }
  }

  /**
   * Generate comprehensive analysis report
   */
  async generateReport() {
    const reportDir = path.join(__dirname, '..', '..', 'analysis');
    await fs.mkdir(reportDir, { recursive: true });

    const reportPath = path.join(reportDir, `${this.testId}.json`);

    // Add system info and analysis summary
    this.results.systemInfo = {
      platform: os.platform(),
      arch: os.arch(),
      cpus: os.cpus().length,
      totalMemory: os.totalmem(),
      freeMemory: os.freemem(),
      nodeVersion: process.version
    };

    this.results.analysis = this.generateAnalysis();

    await fs.writeFile(reportPath, JSON.stringify(this.results, null, 2));

    // Also generate human-readable summary
    const summaryPath = path.join(reportDir, `${this.testId}-summary.md`);
    await fs.writeFile(summaryPath, this.generateMarkdownSummary());
  }

  /**
   * Generate analysis insights from test results
   */
  generateAnalysis() {
    const analysis = {
      maxSafeConcurrency: 1,
      primaryBottlenecks: [],
      recommendations: [],
      riskFactors: []
    };

    // Analyze Task tool limits
    const taskToolSuccess = Object.entries(this.results.taskToolLimits)
      .filter(([_, result]) => result.success)
      .map(([count, _]) => parseInt(count));

    if (taskToolSuccess.length > 0) {
      analysis.maxSafeConcurrency = Math.max(...taskToolSuccess);
    }

    // Identify bottlenecks
    if (analysis.maxSafeConcurrency < 3) {
      analysis.primaryBottlenecks.push('Task tool concurrency limitations');
    }

    // Resource analysis
    const resourceData = this.results.resourceUsage;
    if (resourceData[3] && resourceData[3].memoryDelta > 500 * 1024 * 1024) { // 500MB
      analysis.primaryBottlenecks.push('High memory usage scaling');
    }

    // MCP server analysis
    const mcpLimits = this.results.mcpServerLimits;
    for (const [server, limits] of Object.entries(mcpLimits)) {
      const maxConcurrent = Math.max(...Object.keys(limits).map(k => parseInt(k)));
      if (maxConcurrent < 3) {
        analysis.primaryBottlenecks.push(`${server} concurrency limits`);
      }
    }

    // Generate recommendations
    if (analysis.maxSafeConcurrency >= 3) {
      analysis.recommendations.push('Task tool can handle moderate concurrency - focus on coordination');
    } else {
      analysis.recommendations.push('Task tool has concurrency limits - need alternative approach');
    }

    if (analysis.primaryBottlenecks.length === 0) {
      analysis.recommendations.push('No major bottlenecks found - can proceed with concurrent design');
    } else {
      analysis.recommendations.push('Address bottlenecks before scaling concurrency');
    }

    return analysis;
  }

  /**
   * Generate human-readable markdown summary
   */
  generateMarkdownSummary() {
    const analysis = this.results.analysis;

    return `# Concurrency Analysis Report

## Test Overview
- **Test ID**: ${this.testId}
- **Timestamp**: ${this.results.timestamp}
- **System**: ${this.results.systemInfo.platform} ${this.results.systemInfo.arch}

## Key Findings

### Maximum Safe Concurrency
**${analysis.maxSafeConcurrency}** concurrent agents can be safely executed

### Primary Bottlenecks
${analysis.primaryBottlenecks.length > 0
  ? analysis.primaryBottlenecks.map(b => `- ${b}`).join('\n')
  : '- No major bottlenecks identified'
}

### Recommendations
${analysis.recommendations.map(r => `- ${r}`).join('\n')}

## Detailed Results

### Task Tool Concurrency
${Object.entries(this.results.taskToolLimits).map(([count, result]) =>
  `- **${count} agents**: ${result.success ? '‚úÖ Success' : '‚ùå Failed'} ${result.duration ? `(${result.duration}ms)` : ''}`
).join('\n')}

### MCP Server Limits
${Object.entries(this.results.mcpServerLimits).map(([server, limits]) =>
  `- **${server}**: Max ${Math.max(...Object.keys(limits).map(k => parseInt(k)))} concurrent operations`
).join('\n')}

### Resource Usage
- Baseline memory: ${Math.round(this.results.resourceUsage.baseline?.memory / 1024 / 1024)}MB
- Memory scaling appears ${this.results.resourceUsage[3]?.memoryDelta > 200 * 1024 * 1024 ? 'concerning' : 'acceptable'}

## Next Steps
Based on these findings, the next phase should focus on:
${analysis.recommendations.map(r => `1. ${r}`).join('\n')}
`;
  }

  // Helper methods
  async getSystemResources() {
    return {
      memory: process.memoryUsage().heapUsed,
      cpu: process.cpuUsage(),
      loadAvg: os.loadavg()[0]
    };
  }

  async simulateAgentWork(agentName) {
    // Simulate typical agent operations
    const projectRoot = path.join(__dirname, '..', '..', '..');
    const operations = [
      fs.readFile(path.join(projectRoot, 'package.json'), 'utf8').catch(() => 'mock package.json'),
      fs.readdir(projectRoot).catch(() => ['mock', 'files']),
      this.sleep(Math.random() * 500 + 200)
    ];

    const startTime = Date.now();
    await Promise.all(operations);

    return {
      agent: agentName,
      duration: Date.now() - startTime,
      memoryUsage: process.memoryUsage().heapUsed
    };
  }

  async simulateMcpOperation(serverName, operation, index) {
    // Mock MCP operation - in real implementation would use actual MCP calls
    await this.sleep(Math.random() * 200 + 100);
    return {
      server: serverName,
      operation,
      index,
      timestamp: Date.now()
    };
  }

  async simulateFileRead(filename, agentName) {
    try {
      const content = await fs.readFile(filename, 'utf8');
      return {
        agent: agentName,
        file: filename,
        size: content.length,
        success: true
      };
    } catch (error) {
      return {
        agent: agentName,
        file: filename,
        error: error.message,
        success: false
      };
    }
  }

  async simulateFileWrite(filepath, agentName) {
    try {
      const data = JSON.stringify({ agent: agentName, timestamp: Date.now() });
      await fs.writeFile(filepath, data);
      return {
        agent: agentName,
        file: filepath,
        success: true
      };
    } catch (error) {
      return {
        agent: agentName,
        file: filepath,
        error: error.message,
        success: false
      };
    }
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// CLI execution
if (require.main === module) {
  const tester = new ConcurrencyTester();
  tester.runAnalysis().catch(error => {
    console.error(chalk.red(`\nAnalysis failed: ${error.message}`));
    process.exit(1);
  });
}

module.exports = ConcurrencyTester;